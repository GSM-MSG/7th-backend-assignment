# 과제

* 오버라이딩
* 오버로딩

<br>

## 오버라이딩

* 오버라이딩이란?
   * 부모 클래스로 부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라 한다 -> 간단히 말하면 메서드를 다시 정의하는 것이다
   
* 코드
```
public class A
{
   int age = 10;
   public void setAge(int age)
   {
      this.age = age;
   }
}

class B extends A
{
   public void setAge(int age)
   {
      this.age = age+10;
   }
}
```
-위에서 B클래스가 A클래스를 상속받고 있다   
-상속 관계이므로 B에서는 setAge() 메서드를 그대로 사용할 수 있다 -> 그러나 여기에서는 메서드의 기능을 약간 변경해서 사용하고 있다   
   
*이러한 식으로 상속을 받은 부모의 메서드를 필요에 맞게 다시 정의해서 사용하는 것이 오버라이딩이다*

   
* 오버라이딩의 조건
   * 오버라이딩은 메서드의 내용만 새로 작성하는 것이므로 메서드의 선언부는 부모의 것과 완전히 일치해야한다
```
자식 클래스에서 오버라이딩하는 메서드는 부모 클래스의 메서드와

1. 이름이 같아야 한다
2. 매개변수가 같아야 한다
3. 리턴 타입이 같아야 한다
```

* 접근 제어자와 예외는 제한된 조건에서만 다르게 변경할 수 있다
   1. 접근 제어자는 부모 클래스의 메서드보다 좁은 범위로 변경할 수 있다
      -만일 부모 클래스에 정의된 메서드의 접근 제어자가 protected 라면, 오버라이딩 하는 자식 클래스의 메서드는 접근 제어자가          protected나 public이어야 한다
   2. 부모 클래스의 메서드보다 많은 수의 예외를 선언할 수 있다
      -아래의 코드를 보면 Child클래스의 parentMethod()에 선언된 예외의 개수가 부모인 Parent클래스의 parentMethod()에
      선언된 예외의 개수보다 적이므로 바르게 오버라이딩 하였다
```
import java.io.I0Exception;
import java.sql.SQLExecption

public class Parent
{
   void parentMethod() throws I0Exception, SQLException
   {
      // ...
   }
}

class Child extends Parent
{   // 에러...
   void parentMethod() throws Exception
   {
      // ...
   }
}
```
-여기서 주의해야 할 점은 단순히 선언된 예외의 개수으이 문제가 아니라는 점이다
```
import java.io.I0Exception;
import java.sql.SQLException;

public class Parent
{
   void parentMethoed() throws I0Exception, SQLException
   {
      // ...
   }
}

class Child extends Parent
{   // 에러...
   void parentMethod() throw Exception
   {
      // ...
   }
}
```
-만일 위와 같이 오버라이딩을 하였다면, 분명히 부모 클래스에 정의된 메서드보다 적인 개수의 에외를 선언한 것처럼 보이지만 Exception은 모든 예외의 최고 조상이므로 가장 많은 개수와 예외를 던질 수 있도록 선언한 것이다

```
부모 클래스의 메서드를 자식 클래스에서 오버라이딩 할 떄

1. 접근 제어자를 부모 클래스의 메서드보다 좁은 범위롤 변경할 수 없다
2. 예외는 부모 클래스의 메서드보다 많이 선언할 수 없다
3. 인스턴스 메서드를 static메서드로 또는 그 반대로 변경할 수 없다
```

* 간단히
   * 기존에 없는 새로운 매서드를 정의하는 것

<br>

## 오버로딩

* 오버로딩이란?
   * 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 오버로딩이라 한다

* 오버로딩의 조건
   * 같은 이름의 메서드를 정의한다고 해서 무조건 오버로딩인 것은 아니다
```
1. 메서드 이름이 같아야 한다
2. 매개변수의 개수 또는 타입이 달라야 한다
```
   * 비록 메서드의 이름이 같다 하더라고 매개변수가 다르면 서로 구별될 수 있기 때문에 오버로딩이 가능한 것이다
   * 위 조건을 만족시키지 못하는 메서드는 중복 정의로 간주되어 컴파일 시에 에러가 발생한다
   * 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로, 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다

* 오버로딩 예시
   * 오버로딩의 예로 가장 대표적ㅇ니 것은 println메서드이다
   * 지금까지 println메서드 괄호 안에 값만 지정해주면 출력시 어려움이 없었지만, 실제로는 println메소드를 호출할 때 매개변수로 지정하는 값의 타입에 따라서 호출되는 println메서드가 된다
```
Class A
   {
      public void add(int a, int b) {return a+b;}
      public void add(double a, double b) {return a+b;}
      public void add(long a, long b) {return a+b;}
   }
```
-위 메서드 모둔 int형과 long형 매개변수가 하나하나씩 선언되어 있지만, 서로 순서가 다른 경우이다 -> 이 경우에는 호출 시 매개변수의 값에 의해 호출될 메서드가 구분될 수 있으므로 중복된 메서드 정의가 아닌 오버로딩으로 간주한다
-이처럼 단지 매개변수의 순서만을 다르게 하여 오버로딩을 구현하면, 사용자가 매개변수의 순서를 외우지 않아도 되는 장접이 있지만, 오ㄹ히려 단범이 될 수도 있기 때문에 주의해야한다
   
* 오버로딩의 장점
   1. 기억하기 쉽고 이름도 짧할 수 있어서 오류의 가능성을 많이 줄일 수 있다
   2. 메소드의 이름을 절약할 수 있다는 것

* 간단히
   * 기존에 없는 새로운 메서드를 정의하는 것

